<!doctype html>
<html lang="ja">
<head>
    <meta charset="utf-8" />
    <title>人物通過・滞在カウンター Pro (Layout Optimized)</title>
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <style>
        :root { color-scheme: dark; }
        body { font-family: system-ui, sans-serif; margin:0; background:#111; color:#eee; }
        header { padding:12px 16px; background:#222; display:flex; gap:16px; align-items:center; flex-wrap:wrap; position:sticky; top:0; z-index:10; border-bottom:1px solid #444; }
        
        main { display:grid; grid-template-columns: 720px 1fr; gap:16px; padding:16px; }
        .panel { padding:16px; background:#1e1e1e; border-radius:8px; margin-bottom:16px; display: flex; flex-direction: column; }
        
        .row { display:flex; gap:12px; flex-wrap:wrap; align-items:center; margin-bottom:12px; }
        button, select, input { padding:8px 12px; border-radius:6px; border:1px solid #555; background:#2a2a2a; color:#eee; cursor:pointer; font-size: 14px; }
        button:hover { background: #333; }
        button:disabled { opacity: 0.5; cursor: default; }
        button#startBtn { background: #007bff; border:none; color: white; }
        button#stopBtn { background: #dc3545; border:none; color: white; }
        
        /* 映像エリア */
        #wrap { position:relative; overflow:hidden; width:704px; height:396px; border-radius:8px; background:#000; border:1px solid #333; margin: 0 auto; }
        video { position:absolute; left:0; top:0; width:100%; height:100%; object-fit:contain; z-index:1; }
        canvas { position:absolute; left:0; top:0; width:100%; height:100%; z-index:2; pointer-events:none; }
        .line { position:absolute; top:0; width:2px; background:rgba(0,229,255,0.8); z-index:3; display:none; }
        .area-box { position:absolute; border:2px dashed rgba(255,204,102,0.6); z-index:3; display:none; pointer-events:none; }
        
        /* カウンター表示 */
        .count-grid { display: grid; grid-template-columns: repeat(4, 1fr); gap: 10px; text-align: center; margin-top: 15px; }
        .count-item { background: #252525; padding: 10px; border-radius: 6px; }
        .count { font-size: 28px; font-weight: 700; display: block; }
        .ok { color:#3fd88f; }
        .warn { color:#ffcc66; }
        
        /* 履歴・グラフエリア */
        .table-container { flex-grow: 1; max-height: 400px; overflow-y: auto; border: 1px solid #333; border-radius: 4px; margin-bottom: 20px; }
        table { width:100%; border-collapse: collapse; font-size:13px; }
        th { position: sticky; top: 0; background: #2a2a2a; padding: 10px; }
        td { border-bottom: 1px solid #333; padding: 8px; text-align: center; }
        
        #chartContainer { height: 250px; width: 100%; background: #181818; padding: 10px; border-radius: 8px; box-sizing: border-box; }
        
        .diag { font-size:12px; color:#9fd; margin-top:12px; font-family: monospace; }

        @media (max-width: 1150px) { 
            main { grid-template-columns: 1fr; } 
            #wrap { width: 100%; height: auto; aspect-ratio: 16/9; } 
        }
    </style>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.16.0/dist/tf.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/coco-ssd@2.2.2"></script>
    <script src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
</head>
<body>

<header>
    <div style="font-weight:bold; font-size:1.2em;">人物通過・滞在カウンター Pro</div>
    <div id="status" style="font-size:12px; color:#aaa;">ライブラリ読込中...</div>
    <div style="margin-left:auto; display:flex; gap:10px; align-items:center;">
        <label>集計間隔(分): <input type="number" id="aggIntervalMin" value="2" min="1" max="60" style="width:50px;"></label>
    </div>
</header>

<main>
    <section class="panel">
        <div class="row">
            <button id="startBtn">解析開始</button>
            <button id="stopBtn" disabled>停止</button>
            <select id="modeSel">
                <option value="midline">中央ライン通過判定</option>
                <option value="area">エリア進入判定 (中央40%)</option>
            </select>
            <select id="displayMode">
                <option value="both">映像＋解析枠</option>
                <option value="frameOnly">解析枠のみ</option>
                <option value="videoOnly">映像のみ</option>
            </select>
            <button id="exportExcelBtn" disabled>Excel出力</button>
        </div>

        <div id="wrap">
            <video id="video" autoplay playsinline muted></video>
            <canvas id="overlay"></canvas>
            <div id="midline" class="line"></div>
            <div id="areaBox" class="area-box"></div>
        </div>

        <div class="count-grid">
            <div class="count-item">左→右 / 進入<br><span class="count ok" id="liveL2R">0</span></div>
            <div class="count-item">右→左 / 退出<br><span class="count ok" id="liveR2L">0</span></div>
            <div class="count-item">滞在(1分+)<br><span class="count warn" id="liveStayers">0</span></div>
            <div class="count-item">現在人数<br><span class="count" id="currentInFrame">0</span></div>
        </div>
        <div id="diag" class="diag">システム待機中...</div>
    </section>

    <section class="panel">
        <h3 style="margin-top:0; font-size:16px;">履歴データ: <span id="intervalLabel" style="font-weight:normal; color:#aaa;">-</span></h3>
        
        <div class="table-container">
            <table>
                <thead>
                    <tr><th>時間枠</th><th>L→R/進</th><th>R→L/退</th><th>滞在</th></tr>
                </thead>
                <tbody id="tableBody">
                    </tbody>
            </table>
        </div>

        <div id="chartContainer">
            <canvas id="historyChart"></canvas>
        </div>
    </section>
</main>

<script>
/**
 * 人物通過・滞在カウンター Pro Logic
 */
let model, stream, running = false;
const video = document.getElementById('video');
const canvas = document.getElementById('overlay');
const ctx = canvas.getContext('2d');
const midline = document.getElementById('midline');
const areaBox = document.getElementById('areaBox');
let chart;

let nextId = 1;
const tracks = new Map();
let aggregatorTimer = null;
let intervalStartMs = 0;
let intervalStats = { L2R: 0, R2L: 0, stayers: new Set() };
const intervalHistory = [];

// --- 初期化 ---
window.addEventListener('DOMContentLoaded', async () => {
    initChart();
    try {
        document.getElementById('status').textContent = 'モデル読み込み中...';
        model = await cocoSsd.load({ base: 'lite_mobilenet_v2' });
        document.getElementById('status').textContent = '準備完了';
        document.getElementById('diag').textContent = 'カメラの「開始」を押すと解析が始まります。';
    } catch(e) {
        document.getElementById('status').textContent = 'エラー';
        console.error(e);
    }
});

function initChart() {
    const ctxChart = document.getElementById('historyChart').getContext('2d');
    chart = new Chart(ctxChart, {
        type: 'bar',
        data: {
            labels: [],
            datasets: [
                { label: 'L→R / 進入', data: [], backgroundColor: '#3fd88f' },
                { label: 'R→L / 退出', data: [], backgroundColor: '#3f98d8' }
            ]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            scales: { 
                y: { beginAtZero: true, grid: { color: '#333' }, ticks: { color: '#aaa' } },
                x: { ticks: { color: '#aaa' } }
            },
            plugins: { legend: { labels: { color: '#eee' }, position: 'bottom' } }
        }
    });
}

async function startSystem() {
    try {
        stream = await navigator.mediaDevices.getUserMedia({ 
            video: { width: { ideal: 1280 }, height: { ideal: 720 }, facingMode: "environment" }, 
            audio: false 
        });
        video.srcObject = stream;
        await video.play();
        
        running = true;
        intervalStartMs = Date.now();
        startLoop();
        resetAggregator();
        updateDisplayModeUI();
        resize(); // 初回リサイズ
        
        document.getElementById('startBtn').disabled = true;
        document.getElementById('stopBtn').disabled = false;
        document.getElementById('exportExcelBtn').disabled = false;
        document.getElementById('status').textContent = '解析中...';
    } catch (e) {
        alert("カメラアクセスエラー: " + e.message);
    }
}

// --- 追跡・カウントロジック ---
function updateTracks(detections) {
    const scoreThr = 0.55;
    const scaleX = canvas.width / video.videoWidth;
    const scaleY = canvas.height / video.videoHeight;

    const currentDets = detections
        .filter(d => d.class === 'person' && d.score > scoreThr)
        .map(d => ({
            x: d.bbox[0] * scaleX, y: d.bbox[1] * scaleY,
            w: d.bbox[2] * scaleX, h: d.bbox[3] * scaleY,
            cx: (d.bbox[0] + d.bbox[2]/2) * scaleX,
            cy: (d.bbox[1] + d.bbox[3]/2) * scaleY
        }));

    const unmatchedTracks = new Set(tracks.keys());

    for (const det of currentDets) {
        let bestId = null;
        let minExpDist = 5000;

        for (const id of unmatchedTracks) {
            const t = tracks.get(id);
            const last = t.path[t.path.length - 1];
            const dist = Math.pow(det.cx - last.cx, 2) + Math.pow(det.cy - last.cy, 2);
            if (dist < minExpDist) {
                minExpDist = dist;
                bestId = id;
            }
        }

        if (bestId !== null) {
            const t = tracks.get(bestId);
            t.x = det.x; t.y = det.y; t.w = det.w; t.h = det.h;
            t.path.push({ cx: det.cx, cy: det.cy });
            if(t.path.length > 20) t.path.shift(); // メモリ節約
            t.lastSeen = Date.now();
            unmatchedTracks.delete(bestId);
            processCounting(t);
        } else {
            const newId = nextId++;
            tracks.set(newId, {
                id: newId, x: det.x, y: det.y, w: det.w, h: det.h,
                path: [{ cx: det.cx, cy: det.cy }],
                startMs: Date.now(), lastSeen: Date.now(),
                counted: false, stayed: false, inArea: false
            });
        }
    }

    for (const id of unmatchedTracks) {
        if (Date.now() - tracks.get(id).lastSeen > 1000) tracks.delete(id);
    }
}

function processCounting(t) {
    if (t.counted) return;
    const mode = document.getElementById('modeSel').value;
    const canvasW = canvas.width;
    const canvasH = canvas.height;
    
    if (t.path.length < 2) return;
    const curr = t.path[t.path.length - 1];
    const prev = t.path[t.path.length - 2];

    if (mode === 'midline') {
        const midX = canvasW / 2;
        if (prev.cx < midX && curr.cx >= midX) {
            intervalStats.L2R++; t.counted = true;
        } else if (prev.cx > midX && curr.cx <= midX) {
            intervalStats.R2L++; t.counted = true;
        }
    } else {
        const ax1 = canvasW * 0.3, ax2 = canvasW * 0.7;
        const ay1 = canvasH * 0.3, ay2 = canvasH * 0.7;
        const isInside = (p) => (p.cx > ax1 && p.cx < ax2 && p.cy > ay1 && p.cy < ay2);
        
        if (!t.inArea && isInside(curr)) {
            intervalStats.L2R++; t.inArea = true;
        } else if (t.inArea && !isInside(curr)) {
            intervalStats.R2L++; t.inArea = false;
        }
    }

    if (!t.stayed && (Date.now() - t.startMs > 60000)) {
        t.stayed = true;
        intervalStats.stayers.add(t.id);
    }
}

// --- メインループ ---
async function startLoop() {
    if (!running) return;
    const startTime = performance.now();
    const detections = await model.detect(video);
    updateTracks(detections);
    drawOverlay();
    
    document.getElementById('liveL2R').textContent = intervalStats.L2R;
    document.getElementById('liveR2L').textContent = intervalStats.R2L;
    document.getElementById('liveStayers').textContent = intervalStats.stayers.size;
    document.getElementById('currentInFrame').textContent = tracks.size;
    
    const elapsed = performance.now() - startTime;
    setTimeout(startLoop, Math.max(0, 66 - elapsed));
}

// --- 集計・UI ---
function resetAggregator() {
    if (aggregatorTimer) clearTimeout(aggregatorTimer);
    const mins = parseInt(document.getElementById('aggIntervalMin').value) || 2;
    aggregatorTimer = setTimeout(finishInterval, mins * 60000);
    updateIntervalLabel(mins);
}

function finishInterval() {
    const now = new Date();
    const timeStr = now.getHours().toString().padStart(2, '0') + ":" + now.getMinutes().toString().padStart(2, '0');
    
    const entry = {
        time: timeStr,
        l2r: intervalStats.L2R,
        r2l: intervalStats.R2L,
        stayers: intervalStats.stayers.size
    };
    
    intervalHistory.push(entry);
    updateTable(entry);
    updateChart();
    
    intervalStats = { L2R: 0, R2L: 0, stayers: new Set() };
    intervalStartMs = Date.now();
    resetAggregator();
}

function updateIntervalLabel(mins) {
    const start = new Date(intervalStartMs);
    const end = new Date(intervalStartMs + mins * 60000);
    const format = (d) => d.toLocaleTimeString([], {hour:'2-digit', minute:'2-digit'});
    document.getElementById('intervalLabel').textContent = `${format(start)} 〜 ${format(end)}`;
}

function updateTable(e) {
    const row = `<tr><td>${e.time}</td><td>${e.l2r}</td><td>${e.r2l}</td><td>${e.stayers}</td></tr>`;
    document.getElementById('tableBody').insertAdjacentHTML('afterbegin', row);
}

function updateChart() {
    const last10 = intervalHistory.slice(-10);
    chart.data.labels = last10.map(h => h.time);
    chart.data.datasets[0].data = last10.map(h => h.l2r);
    chart.data.datasets[1].data = last10.map(h => h.r2l);
    chart.update();
}

function drawOverlay() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    const viewMode = document.getElementById('displayMode').value;
    if (viewMode === 'videoOnly') return;

    ctx.lineWidth = 2;
    ctx.font = '14px sans-serif';

    for (const t of tracks.values()) {
        ctx.strokeStyle = t.stayed ? '#ffcc66' : '#00e5ff';
        ctx.strokeRect(t.x, t.y, t.w, t.h);
        ctx.fillStyle = t.stayed ? '#ffcc66' : '#00e5ff';
        ctx.fillText(`ID:${t.id}${t.stayed ? ' (STAY)':''}`, t.x, t.y - 5);
        
        if (t.path.length > 1) {
            ctx.beginPath();
            ctx.strokeStyle = 'rgba(0, 229, 255, 0.3)';
            ctx.moveTo(t.path[0].cx, t.path[0].cy);
            for(let p of t.path) ctx.lineTo(p.cx, p.cy);
            ctx.stroke();
        }
    }
}

function updateDisplayModeUI() {
    const mode = document.getElementById('modeSel').value;
    const rect = canvas.getBoundingClientRect();
    if (mode === 'midline') {
        midline.style.display = 'block';
        midline.style.left = (rect.width / 2) + 'px';
        areaBox.style.display = 'none';
    } else {
        midline.style.display = 'none';
        areaBox.style.display = 'block';
        areaBox.style.left = '30%'; areaBox.style.top = '30%';
        areaBox.style.width = '40%'; areaBox.style.height = '40%';
    }
}

// --- イベントリスナー ---
document.getElementById('startBtn').addEventListener('click', startSystem);
document.getElementById('stopBtn').addEventListener('click', () => { 
    running = false; 
    if(stream) stream.getTracks().forEach(t => t.stop());
    document.getElementById('status').textContent = '停止中';
    document.getElementById('startBtn').disabled = false;
    document.getElementById('stopBtn').disabled = true;
});

document.getElementById('modeSel').addEventListener('change', updateDisplayModeUI);

document.getElementById('exportExcelBtn').addEventListener('click', () => {
    if (intervalHistory.length === 0) { alert("データがありません"); return; }
    const wb = XLSX.utils.book_new();
    const ws = XLSX.utils.json_to_sheet(intervalHistory);
    XLSX.utils.book_append_sheet(wb, ws, "集計レポート");
    XLSX.writeFile(wb, `counter_report_${new Date().toISOString().slice(0,10)}.xlsx`);
});

function resize() {
    const wrap = document.getElementById('wrap');
    canvas.width = wrap.clientWidth;
    canvas.height = wrap.clientHeight;
    updateDisplayModeUI();
}
window.addEventListener('resize', resize);
</script>
</body>
</html>
