<!doctype html>
<html lang="ja">
<head>
    <meta charset="utf-8" />
    <title>人物通過カウンター Lite (Stability Fix)</title>
    <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
    <style>
        :root { color-scheme: dark; }
        body { font-family: system-ui, sans-serif; margin:0; background:#111; color:#eee; overflow-x: hidden; }
        header { padding: 12px; background: #222; border-bottom: 1px solid #444; }
        main { padding: 10px; display: flex; flex-direction: column; gap: 12px; }
        .panel { background: #1e1e1e; border-radius: 8px; padding: 12px; border: 1px solid #333; }
        .controls { display: grid; grid-template-columns: 1fr 1fr; gap: 8px; margin-bottom: 10px; }
        button, select, input { padding: 12px; border-radius: 6px; border: 1px solid #555; background: #2a2a2a; color: #eee; font-size: 14px; width: 100%; }
        button#startBtn { background: #007bff; border: none; font-weight: bold; }
        button#stopBtn { background: #dc3545; border: none; }
        #wrap { position: relative; width: 100%; aspect-ratio: 16/9; background: #000; border-radius: 6px; overflow: hidden; border: 1px solid #444; }
        video { width: 100%; height: 100%; object-fit: contain; }
        canvas { position: absolute; left: 0; top: 0; width: 100%; height: 100%; z-index: 2; pointer-events: none; }
        .count-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 8px; }
        .count-item { background: #252525; padding: 10px; border-radius: 6px; text-align: center; border: 1px solid #333; }
        .count-value { font-size: 24px; font-weight: bold; display: block; }
        .ok { color: #3fd88f; }
        .warn { color: #ffcc66; }
        .table-wrap { max-height: 200px; overflow-y: auto; background: #181818; border-radius: 4px; }
        table { width: 100%; border-collapse: collapse; font-size: 12px; }
        th, td { padding: 8px; text-align: center; border-bottom: 1px solid #333; }
        .status-msg { font-size: 11px; color: #9fd; text-align: center; margin-top: 8px; }
    </style>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.16.0/dist/tf.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/coco-ssd@2.2.2"></script>
</head>
<body>

<header>
    <div style="display:flex; justify-content:space-between; align-items:center;">
        <span style="font-weight:bold;">人物カウンター Pro (安定版)</span>
        <span id="status" style="font-size:10px; color:#aaa;">準備中</span>
    </div>
</header>

<main>
    <section class="panel">
        <div class="controls">
            <button id="startBtn">解析開始</button>
            <button id="stopBtn" disabled>停止</button>
        </div>
        <div style="display:flex; align-items:center; gap:8px; margin-bottom:10px;">
            <select id="modeSel" style="flex:2;">
                <option value="midline">中央ライン通過判定</option>
                <option value="area">エリア進入判定</option>
            </select>
            <input type="number" id="aggIntervalMin" value="1" min="1" style="flex:1;">
            <span style="font-size:12px;">分</span>
        </div>
        <div id="wrap">
            <video id="video" autoplay playsinline muted></video>
            <canvas id="overlay"></canvas>
        </div>
        <div id="diag" class="status-msg">読込完了までお待ちください</div>
    </section>

    <section class="panel">
        <div class="count-grid">
            <div class="count-item"><span style="font-size:10px; color:#999;">進入</span><span class="count-value ok" id="liveL2R">0</span></div>
            <div class="count-item"><span style="font-size:10px; color:#999;">退出</span><span class="count-value ok" id="liveR2L">0</span></div>
            <div class="count-item"><span style="font-size:10px; color:#999;">滞在</span><span class="count-value warn" id="liveStayers">0</span></div>
            <div class="count-item"><span style="font-size:10px; color:#999;">画面内</span><span class="count-value" id="currentInFrame">0</span></div>
        </div>
    </section>

    <section class="panel">
        <div class="table-wrap">
            <table>
                <thead><tr><th>時刻</th><th>進</th><th>退</th><th>滞在</th></tr></thead>
                <tbody id="tableBody"></tbody>
            </table>
        </div>
    </section>
</main>

<script>
let model, stream, running = false;
const video = document.getElementById('video');
const canvas = document.getElementById('overlay');
const ctx = canvas.getContext('2d');

const tracks = new Map();
let nextId = 1;
let intervalStats = { L2R: 0, R2L: 0, stayers: new Set() };
let lastAggTime = Date.now();

window.addEventListener('load', async () => {
    try {
        // GPUメモリ管理の設定
        tf.env().set('WEBGL_DELETE_TEXTURE_THRESHOLD', 0);
        model = await cocoSsd.load({ base: 'lite_mobilenet_v2' });
        document.getElementById('status').textContent = '準備完了';
        document.getElementById('diag').textContent = '「開始」で解析を開始します';
    } catch(e) {
        document.getElementById('diag').textContent = 'モデルの読込に失敗しました';
    }
});

async function startSystem() {
    try {
        stream = await navigator.mediaDevices.getUserMedia({ 
            video: { facingMode: "environment", width: 640, height: 480 }, audio: false 
        });
        video.srcObject = stream;
        await video.play();
        running = true;
        document.getElementById('startBtn').disabled = true;
        document.getElementById('stopBtn').disabled = false;
        document.getElementById('diag').textContent = '解析中...（長時間使用時は発熱に注意）';
        lastAggTime = Date.now();
        requestAnimationFrame(predictLoop);
    } catch (e) {
        alert("カメラへのアクセスを許可してください");
    }
}

async function predictLoop() {
    if (!running) return;

    // tf.tidyでメモリリークを防止
    const detections = await tf.tidy(() => {
        return model.detect(video);
    });

    updateCounting(detections);
    checkAggregation();
    
    // 負荷軽減のため、少しだけ待機時間を設ける（バッテリーとメモリの保護）
    setTimeout(() => {
        requestAnimationFrame(predictLoop);
    }, 50); 
}

function updateCounting(detections) {
    const scaleX = canvas.width / video.videoWidth;
    const scaleY = canvas.height / video.videoHeight;
    const midX = canvas.width / 2;
    const mode = document.getElementById('modeSel').value;
    
    const currentPeople = detections.filter(d => d.class === 'person' && d.score > 0.5);
    const unmatched = new Set(tracks.keys());

    for (const d of currentPeople) {
        const cx = (d.bbox[0] + d.bbox[2]/2) * scaleX;
        const cy = (d.bbox[1] + d.bbox[3]/2) * scaleY;
        
        let bestId = null;
        let minDist = 50; 

        for (const id of unmatched) {
            const t = tracks.get(id);
            const dist = Math.hypot(cx - t.x, cy - t.y);
            if (dist < minDist) { minDist = dist; bestId = id; }
        }

        if (bestId !== null) {
            const t = tracks.get(bestId);
            const prevX = t.x;
            t.x = cx; t.y = cy; t.lastSeen = Date.now();
            unmatched.delete(bestId);

            if (!t.counted) {
                if (mode === 'midline') {
                    if (prevX < midX && cx >= midX) { intervalStats.L2R++; t.counted = true; }
                    else if (prevX > midX && cx <= midX) { intervalStats.R2L++; t.counted = true; }
                } else {
                    const inA = (pX, pY) => (pX > canvas.width*0.3 && pX < canvas.width*0.7 && pY > canvas.height*0.3 && pY < canvas.height*0.7);
                    if (!t.inArea && inA(cx, cy)) { intervalStats.L2R++; t.inArea = true; }
                    else if (t.inArea && !inA(cx, cy)) { intervalStats.R2L++; t.inArea = false; }
                }
            }
            if (!t.stayed && (Date.now() - t.startMs > 60000)) { t.stayed = true; intervalStats.stayers.add(t.id); }
        } else {
            const id = nextId++;
            tracks.set(id, { id, x: cx, y: cy, startMs: Date.now(), lastSeen: Date.now(), counted: false, stayed: false, inArea: false });
        }
    }

    for (const id of unmatched) { if (Date.now() - tracks.get(id).lastSeen > 1500) tracks.delete(id); }

    // 数値更新
    document.getElementById('liveL2R').textContent = intervalStats.L2R;
    document.getElementById('liveR2L').textContent = intervalStats.R2L;
    document.getElementById('liveStayers').textContent = intervalStats.stayers.size;
    document.getElementById('currentInFrame').textContent = tracks.size;
    
    // 描画
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    ctx.strokeStyle = '#00e5ff'; ctx.lineWidth = 2;
    for(const t of tracks.values()) {
        ctx.strokeRect(t.x-20, t.y-40, 40, 80);
    }
}

function checkAggregation() {
    const intervalMs = (parseInt(document.getElementById('aggIntervalMin').value) || 1) * 60000;
    if (Date.now() - lastAggTime > intervalMs) {
        const now = new Date();
        const timeStr = now.getHours().toString().padStart(2,'0') + ":" + now.getMinutes().toString().padStart(2,'0');
        const row = `<tr><td>${timeStr}</td><td>${intervalStats.L2R}</td><td>${intervalStats.R2L}</td><td>${intervalStats.stayers.size}</td></tr>`;
        document.getElementById('tableBody').insertAdjacentHTML('afterbegin', row);
        
        intervalStats = { L2R: 0, R2L: 0, stayers: new Set() };
        lastAggTime = Date.now();
    }
}

document.getElementById('startBtn').addEventListener('click', startSystem);
document.getElementById('stopBtn').addEventListener('click', () => {
    running = false;
    if(stream) stream.getTracks().forEach(t => t.stop());
    document.getElementById('startBtn').disabled = false;
    document.getElementById('stopBtn').disabled = true;
    document.getElementById('diag').textContent = '停止しました';
});

function resize() {
    canvas.width = video.clientWidth;
    canvas.height = video.clientHeight;
}
window.addEventListener('resize', resize);
</script>
</body>
</html>
