
<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <title>人物通過・滞在カウンター（GitHub Pages版）</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    :root{ color-scheme: dark; }
    body { font-family: system-ui, -apple-system, "Segoe UI", "Yu Gothic", sans-serif; margin:0; background:#111; color:#eee; }
    header { padding:12px 16px; background:#222; display:flex; gap:12px; align-items:center; flex-wrap:wrap; position:sticky; top:0; z-index:10; }
    main { display:grid; grid-template-columns: 720px 1fr; gap:16px; padding:16px; }
    .panel { padding:12px; background:#1e1e1e; border-radius:8px; position:relative; z-index:1; }
    .row { display:flex; gap:12px; flex-wrap:wrap; align-items:center; z-index:2; position:relative; }
    button, select, input { padding:8px 10px; border-radius:6px; border:1px solid #555; background:#2a2a2a; color:#eee; }
    table { width:100%; border-collapse: collapse; }
    th, td { border-bottom: 1px solid #333; padding:8px; text-align:center; }
    thead th { position: sticky; top:0; background:#242424; }
    .badge { display:inline-block; padding:2px 8px; border:1px solid #555; border-radius:999px; font-size:12px; }
    .count { font-size: 28px; font-weight: 700; }
    .ok { color:#3fd88f; }
    .warn { color:#ffcc66; }
    .status, .diag { font-size:12px; opacity:.9; }
    .diag { color:#9fd; }

    /* 表示領域 */
    #wrap { position:relative; overflow:hidden; width:704px; height:396px; border-radius:8px; background:#000; }
    video { position:absolute; left:0; top:0; width:100%; height:100%; object-fit:contain; background:#000; transition: opacity .15s ease; z-index:1; }
    canvas { position:absolute; left:0; top:0; width:100%; height:100%; pointer-events:none; z-index:2; } /* ←クリックを邪魔しない */
    .line { position:absolute; top:0; width:2px; background:rgba(0,229,255,.7); z-index:3; }
  </style>

  <!-- ✅ 正しい HTTPS CDN（GitHub Pagesと相性良し） -->
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.16.0/dist/tf.min.js" defer></script>
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/coco-ssd@2.2.2" defer></script>
  <script src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js" defer></script>
</head>
<body>
  <header>
    <div>人物通過・滞在カウンター <span class="badge">端末内推論 / 2分集計 / Excel出力</span></div>
    <div class="status" id="status">準備中...</div>
    <div class="badge">※映像・結果は送信せず端末内処理</div>
  </header>

  <main>
    <!-- 左ペイン：映像＋オーバーレイ -->
    <section id="view" class="panel">
      <div class="row">
        <button id="startBtn">開始</button>
        <button id="stopBtn" disabled>停止</button>
        <button id="toggleBoxBtn" disabled>枠表示 ON/OFF</button>
        <label>方式:
          <select id="modeSel">
            <option value="midline">中央ライン越え</option>
            <option value="edge">端→端到達</option>
          </select>
        </label>
        <label>表示モード:
          <select id="displayMode">
            <option value="both">映像＋枠</option>
            <option value="frameOnly">枠のみ（映像非表示）</option>
            <option value="videoOnly">映像のみ（枠非表示）</option>
          </select>
        </label>
        <label>しきい値:
          <input type="number" id="scoreThr" value="0.5" min="0" max="1" step="0.05" />
        </label>
        <label>推論間隔(ms):
          <input type="number" id="intervalMs" value="200" min="50" step="50" />
        </label>
        <button id="exportExcelBtn" disabled>Excel出力</button>
      </div>

      <div id="wrap">
        <video id="video" autoplay playsinline muted></video>
        <canvas id="overlay"></canvas>
        <div id="midline" class="line" title="中央ライン"></div>
      </div>

      <div class="row" style="margin-top:8px;">
        <div>現在区間（2分）のライブ集計：</div>
        <div>左→右 <span class="count ok" id="liveL2R">0</span></div>
        <div>右→左 <span class="count ok" id="liveR2L">0</span></div>
        <div>滞在1分以上 <span class="count warn" id="liveStayers">0</span></div>
        <div>現在滞在中（1分以上） <span class="count warn" id="currentStaying">0</span></div>
        <div>フレーム内人数 <span class="count" id="currentInFrame">0</span></div>
      </div>

      <div class="diag" id="diag">[診断] ページロード完了待ち…</div>
    </section>

    <!-- 右ペイン：集計テーブル -->
    <section class="panel">
      <div class="row"><div>2分ごとの集計結果</div><span class="badge" id="intervalLabel">未開始</span></div>
      <table>
        <thead>
          <tr>
            <th>区間（開始〜終了）</th>
            <th>左→右</th>
            <th>右→左</th>
            <th>滞在1分以上（ユニーク）</th>
          </tr>
        </thead>
        <tbody id="tableBody"></tbody>
      </table>
    </section>
  </main>

  <!-- ここからアプリ本体（DOMの後に読み込む） -->
  <script>
    // --- 診断メッセージ ---
    const diagEl = document.getElementById('diag');
    window.addEventListener('DOMContentLoaded', () => {
      diagEl.textContent = '[診断] DOM読み込み完了。外部ライブラリを確認中…';
    });

    // --- 参照取得 ---
    let model, stream, running=false, drawBoxes=true;
    const video = document.getElementById('video');
    const canvas = document.getElementById('overlay');
    const ctx = canvas.getContext('2d');
    const statusEl = document.getElementById('status');

    const liveL2R = document.getElementById('liveL2R');
    const liveR2L = document.getElementById('liveR2L');
    const liveStayers = document.getElementById('liveStayers');
    const currentStaying = document.getElementById('currentStaying');
    const currentInFrame = document.getElementById('currentInFrame');
    const intervalLabel = document.getElementById('intervalLabel');
    const tableBody = document.getElementById('tableBody');

    const startBtn = document.getElementById('startBtn');
    const stopBtn = document.getElementById('stopBtn');
    const toggleBoxBtn = document.getElementById('toggleBoxBtn');
    const scoreThrEl = document.getElementById('scoreThr');
    const intervalMsEl = document.getElementById('intervalMs');
    const modeSel = document.getElementById('modeSel');
    const displayModeSel = document.getElementById('displayMode');
    const exportExcelBtn = document.getElementById('exportExcelBtn');

    // --- 状態 ---
    let nextId = 1;
    const tracks = new Map();
    let timerId = null;
    let aggregatorTimer = null;

    let intervalStartMs = 0;
    let intervalStats = { L2R:0, R2L:0, stayers:new Set() };
    const intervalHistory = [];
    const eventsLog = [];

    function now(){ return performance.now(); }
    function setStatus(s){ statusEl.textContent = s; }

    function resizeCanvas(){
      const rect = document.getElementById('wrap').getBoundingClientRect();
      const dpr = window.devicePixelRatio || 1;
      canvas.width  = Math.round(rect.width  * dpr);
      canvas.height = Math.round(rect.height * dpr);
      canvas.style.width  = rect.width + 'px';
      canvas.style.height = rect.height + 'px';
      const midline = document.getElementById('midline');
      midline.style.height = rect.height + 'px';
      midline.style.left   = Math.round(rect.width / 2) + 'px';
    }

    async function initCamera(){
      try{
        stream = await navigator.mediaDevices.getUserMedia({
          video: { width: { ideal: 1280 }, height: { ideal: 720 } }, audio:false
        });
        video.srcObject = stream;
        await video.play();
        resizeCanvas();
        diagEl.textContent = '[診断] カメラ初期化OK。';
      }catch(e){
        diagEl.textContent = '[診断] カメラ初期化エラー: ' + e.message + '（HTTPSで開き、ブラウザのカメラ許可をONにしてください）';
        throw e;
      }
    }

    async function loadModel(){
      if (!window.cocoSsd || !window.tf){
        const msg = '外部ライブラリ未ロード（CDNブロックや混在コンテンツの可能性）';
        diagEl.textContent = '[診断] ' + msg;
        setStatus(msg);
        throw new Error(msg);
      }
      setStatus('モデル読み込み中...');
      model = await cocoSsd.load({ base: 'lite_mobilenet_v2' });
      setStatus('モデル読み込み完了');
    }

    // --- 追跡ロジック（省略せず記述） ---
    function iou(a,b){const x1=Math.max(a.x,b.x),y1=Math.max(a.y,b.y),x2=Math.min(a.x+a.w,b.x+b.w),y2=Math.min(a.y+a.h,b.y+b.h);const inter=Math.max(0,x2-x1)*Math.max(0,y2-y1);const ua=a.w*a.h+b.w*b.h-inter;return ua?inter/ua:0;}
    function centroid(b){return{cx:b.x+b.w/2,cy:b.y+b.h/2};}
    function dist2(c1,c2){const dx=c1.cx-c2.cx,dy=c1.cy-c2.cy;return dx*dx+dy*dy;}
    function toDisplayBox(b){
      const rect=document.getElementById('wrap').getBoundingClientRect();
      const nativeW=video.videoWidth||rect.width;
      const nativeH=video.videoHeight||rect.height;
      const sx=rect.width/nativeW;
      const sy=rect.height/nativeH;
      const [x,y,w,h]=b.bbox;
      return {x:x*sx,y:y*sy,w:w*sx,h:h*sy,score:b.score};
    }
    function sideOf(x,width){ if(x<width*0.25)return'L'; if(x>width*0.75)return'R'; return'M'; }

    function attachDetections(dets,width){
      const scoreThr=parseFloat(scoreThrEl.value)||0.5;
      const persons=dets.filter(d=>d.class==='person'&&d.score>=scoreThr).map(toDisplayBox);
      const activeIds=new Set(tracks.keys()); const usedTrack=new Set();
      for(const p of persons){
        const c=centroid(p); let bestId=-1,bestScore=-1;
        for(const id of activeIds){
          if(usedTrack.has(id))continue; const t=tracks.get(id);
          if(now()-t.lastSeenMs>3000)continue;
          const scoreIoU=iou({x:t.x,y:t.y,w:t.w,h:t.h},{x:p.x,y:p.y,w:p.w,h:p.h});
          const scoreDist=1/(1+Math.sqrt(dist2(centroid({x:t.x,y:t.y,w:t.w,h:t.h}),c)));
          const score=scoreIoU*0.7+scoreDist*0.3; if(score>bestScore){bestScore=score;bestId=id;}
        }
        if(bestId!==-1&&bestScore>=0.2){
          const t=tracks.get(bestId);
          t.x=p.x;t.y=p.y;t.w=p.w;t.h=p.h; t.path.push(c); t.lastSeenMs=now();
          if(!t.initialSide||t.initialSide==='M'){t.initialSide=sideOf(t.path[0].cx,width);}
          t.currentSide=sideOf(c.cx,width);
          maybeCountPass(t,width);
          if(!t.stayed&&(t.lastSeenMs-t.birthMs)>=60000){
            t.stayed=true; intervalStats.stayers.add(t.id);
            eventsLog.push({timeISO:new Date().toISOString(),event:'stay>=60s',trackId:t.id});
          }
          usedTrack.add(bestId);
        }else{
          const id=nextId++; const s=sideOf(c.cx,width);
          tracks.set(id,{id,x:p.x,y:p.y,w:p.w,h:p.h,path:[c],birthMs:now(),lastSeenMs:now(),initialSide:s,currentSide:s,counted:false,stayed:false});
          usedTrack.add(id);
        }
      }
    }
    function maybeCountPass(t,width){
      if(t.counted)return; const mode=modeSel.value; const midX=width/2; const len=t.path.length; if(len<2)return;
      if(mode==='midline'){
        const prev=t.path[len-2].cx,curr=t.path[len-1].cx;
        if(prev<midX&&curr>=midX){ intervalStats.L2R++; t.counted=true; eventsLog.push({timeISO:new Date().toISOString(),event:'L2R',trackId:t.id}); }
        else if(prev>=midX&&curr<midX){ intervalStats.R2L++; t.counted=true; eventsLog.push({timeISO:new Date().toISOString(),event:'R2L',trackId:t.id}); }
      }else{
        if(t.initialSide==='L'&&t.currentSide==='R'){ intervalStats.L2R++; t.counted=true; eventsLog.push({timeISO:new Date().toISOString(),event:'L2R',trackId:t.id}); }
        else if(t.initialSide==='R'&&t.currentSide==='L'){ intervalStats.R2L++; t.counted=true; eventsLog.push({timeISO:new Date().toISOString(),event:'R2L',trackId:t.id}); }
      }
    }
    function cleanupOldTracks(){ const nowMs=now(); for(const [id,t] of tracks){ if(nowMs-t.lastSeenMs>3000){ tracks.delete(id); } } }
    function draw(){
      const dpr=window.devicePixelRatio||1; ctx.setTransform(dpr,0,0,dpr,0,0);
      const rect=document.getElementById('wrap').getBoundingClientRect();
      ctx.clearRect(0,0,rect.width,rect.height);
      if(!drawBoxes)return;
      ctx.strokeStyle='#00e5ff'; ctx.lineWidth=2; ctx.font='12px system-ui'; ctx.fillStyle='#00e5ff';
      for(const t of tracks.values()){ ctx.strokeRect(t.x,t.y,t.w,t.h); const label=`id:${t.id}${t.stayed?' ⌛':''}${t.counted?' ✓':''}`; ctx.fillText(label,t.x+4,t.y+14); }
    }

    async function step(){
      if(!running)return;
      const dets=await model.detect(video,20);
      const rect=document.getElementById('wrap').getBoundingClientRect();
      attachDetections(dets,rect.width); cleanupOldTracks(); draw();
      currentInFrame.textContent=tracks.size;
      let staying=0; for(const t of tracks.values()){ if(t.stayed&&(now()-t.lastSeenMs)<1500)staying++; }
      currentStaying.textContent=staying;
      liveL2R.textContent=intervalStats.L2R; liveR2L.textContent=intervalStats.R2L; liveStayers.textContent=intervalStats.stayers.size;
    }

    function startLoop(){
      const ms=parseInt(intervalMsEl.value)||200;
      running=true; timerId=setInterval(step,ms);
      intervalStartMs=Date.now(); intervalStats={L2R:0,R2L:0,stayers:new Set()};
      updateIntervalLabel(); aggregatorTimer=setInterval(finishInterval,120000);
      setStatus('推論中...'); exportExcelBtn.disabled=false;
    }
    function stopLoop(){ running=false; clearInterval(timerId); clearInterval(aggregatorTimer); setStatus('停止中'); }
    function updateIntervalLabel(){ const start=new Date(intervalStartMs); const end=new Date(intervalStartMs+120000); intervalLabel.textContent=`${fmt(start)} 〜 ${fmt(end)}（進行中）`; }
    function fmt(d){ const p=n=>String(n).padStart(2,'0'); return `${p(d.getHours())}:${p(d.getMinutes())}:${p(d.getSeconds())}`; }
    function finishInterval(){
      const start=new Date(intervalStartMs); const end=new Date();
      const tr=document.createElement('tr');
      tr.innerHTML=`<td>${fmt(start)} 〜 ${fmt(end)}</td><td>${intervalStats.L2R}</td><td>${intervalStats.R2L}</td><td>${intervalStats.stayers.size}</td>`;
      tableBody.prepend(tr);
      intervalHistory.push({startISO:start.toISOString(),endISO:end.toISOString(),l2r:intervalStats.L2R,r2l:intervalStats.R2L,stayers:intervalStats.stayers.size});
      intervalStartMs=Date.now(); intervalStats={L2R:0,R2L:0,stayers:new Set()}; updateIntervalLabel();
    }

    // --- UI handlers ---
    startBtn.addEventListener('click', async ()=>{
      try{
        startBtn.disabled = true;
        diagEl.textContent = '[診断] 開始クリックを受信→カメラ→モデル読込→推論開始';
        await initCamera();
        await loadModel();
        resizeCanvas();
        applyDisplayMode();
        startLoop();
        stopBtn.disabled = false;
        toggleBoxBtn.disabled = false;
      }catch(e){
        console.error(e);
        setStatus('エラー: '+e.message);
        startBtn.disabled = false;
      }
    });
    stopBtn.addEventListener('click', stopLoop);
    toggleBoxBtn.addEventListener('click', ()=>{ drawBoxes = !drawBoxes; draw(); });
    displayModeSel.addEventListener('change', applyDisplayMode);
    window.addEventListener('resize', resizeCanvas);
    video.addEventListener('loadedmetadata', resizeCanvas);
    window.addEventListener('beforeunload', ()=>{ if(stream) stream.getTracks().forEach(t=>t.stop()); });

    function applyDisplayMode(){
      const mode = displayModeSel.value;
      if (mode === 'frameOnly'){ video.style.opacity = '0'; drawBoxes = true; }
      else if (mode === 'videoOnly'){ video.style.opacity = '1'; drawBoxes = false; draw(); }
      else { video.style.opacity = '1'; drawBoxes = true; draw(); }
    }

    // --- Excel出力 ---
    document.getElementById('exportExcelBtn').addEventListener('click', ()=>{
      try{
        if (!window.XLSX){ setStatus('Excelライブラリ未ロード'); return; }
        const wb = XLSX.utils.book_new();
        const wsSummary = XLSX.utils.json_to_sheet(intervalHistory.map(h => ({
          区間開始ISO:h.startISO, 区間終了ISO:h.endISO, 左→右:h.l2r, 右→左:h.r2l, 滞在1分以上_ユニーク:h.stayers
        })));
        XLSX.utils.book_append_sheet(wb, wsSummary, '2分集計');
        const wsEvents = XLSX.utils.json_to_sheet(eventsLog.map(e => ({
          発生時刻ISO:e.timeISO, イベント:e.event, トラックID:e.trackId
        })));
        XLSX.utils.book_append_sheet(wb, wsEvents, 'イベント');
        const ts = new Date().toISOString().replace(/[:.]/g,'-');
        XLSX.writeFile(wb, `people_flow_${ts}.xlsx`);
        setStatus('Excelを出力しました');
      }catch(err){ console.error(err); setStatus('Excel出力エラー: '+err.message); }
    });
  </script>
</body>
</html>
